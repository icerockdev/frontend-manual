# Общие рекомендации по написанию фронта

## 1. Структура приложения
### 1.1. Используйте create-react-app
Это может показаться менее удобным в настройке, но такое приложение проще поддерживать вам самим, и приходящему после вас разработчику. CRA обновлять проще, чем огромный набор утилит, между которыми существуют проблемы зависимостей. В CRA эту проблему решили за вас.

### 1.2. НИКОГДА не используйте `create-react-app eject`
Используйте `craco` для модификации настроек. Да, это выглядит костылём, но существует огромное число проектов, где заказчик хочет откатить назад `eject`.

### 1.3. Используйте статическую типизацию. Лучше Typescript.
Typescript вшит в CRA. Лучше сразу начать использовать его в проекте, обучаясь по ходу, чем потом тратить кучу времени на его внедрение и исправление ошибок, которые вы допустили, не используя типизацию. При выборе между TS и Flow стоит учитывать, что TS использует большее число проектов.

### 1.4. Сразу настройте eslint и prettier. Не испольльзуйте tslint
Используйте готовые наборы правил вроде [jsx-a11y](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y), [react-airbnb](https://github.com/airbnb/javascript/tree/master/react), [react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks). Код должен быть отформатирован одинаково для всех разработчиков. Можно добавить гит-хук, который будет запускать `eslint --fix` и не давать коммитить код с варнингами
Для Typescript не используйте TSLint, он считается устаревшим. Используйте [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint)
**Если eslint пишет, что у вас проблема, не надо использовать eslint-disable. Ищите красивое решение.**

### 1.5. Yarn или npm?
Yarn. Это разные пакетные менеджеры и yarn считается более прогрессивным.

### 1.6. Берегите yarn.lock и package-lock.json
Это убережет вас от неправильно установленных версий пакетов и непредсказуемой работы приложения в связи с этим

## 2. React. Общие положения
### 2.1 Продумайте архитектуру приложения заранее. Структура папок.
Ниже приведена типовая структура react-приложения. Что важно:
1. Мы разделили бизнес-логику, данные и вёрстку. Об этом будет чуть позже, но используем ли мы `redux` или `mobx`, бизнес-логики в компонентах быть не должно, а данные должны как можно скорее отправляться в общий `store`.
2. Компоненты разделены на контейнеры и, собственно, компоненты. Деление достаточно условное, но контейнеры содержат наборы компонентов, их же мы подключаем к стору, а компоненты несут какое-то простое назначение. Форма логина это контейнер, а текстовый инпут - компонент
3. Компоненты разделены по категориям и лежат на одном уровне. Один компонент - одна папка. Внутри папки `.tsx`-файл, файл стилей (`.scss` это или `.js` для styled-components - не важно). Внутри папки с компонентом нет папок с подкомпонентами. 
4. Зависимые компоненты именуются добавлением к имени главного компонента суффикса. Например: `TextInput` включает в себя `TextInputIcon` и т.д.
```
assets/
    logo.png
src/
   containers/
     main/
       MainContainer/
         index.tsx
         styles.module.scss
         
   components/
     inputs/
       TextInput/
            index.tsx
            styles.module.scss
        TextInputIcon/
            index.tsx
            styles.module.scss
            
    store/
        auth/
        items/
        index.ts
        
    utils/
    styles/
    index.tsx
```
### 2.2. Разделяйте страницы на большее число компонентов.
Если у вас есть, например, страница регистрации, не пишите всю вёрстку в одном компоненте.
Разбейте страницу на блоги, а блоки, если они слишком крупные, так же на блоки. Огромные простыни кода не сможет прочитать не только другой разработчик, но и вы уже через неделю.
```
containers/auth/
    Registration/
components/auth/
    RegistrationTitle/
    RegistrationProfile/
    RegistrationProfileNames/
    RegistrationProfilePhoto/
    RegistrationCredentials/
    RegistrationButtons/
```

### 2.3. Избегайте бизнес-логики и хранения данных в компонентах
Часто в коде новичков можно видеть какую-то сложную логику в методах компонента, иногда там встречаются даже асинхронные запросы. Этого нужно избегать. В будущем будет очень сложно масштабировать, поддерживать и тестировать.
Выносите бизнес-логику в `redux-saga` или в экшны `mobx`, изолируйте вёрстку от бизнес-логики.

Хранение данных так же должно быть сведено к минимуму. Для этого есть хранилища, `redux` или `mobx`. Вы никогда не сможете предсказать, понадобятся вам данные из компонента где-нибудь ещё или нет.

Допустимые случаи хранения данных в компоненте - когда это данные формы, которые вам нужно скопировать из основного хранилища перед редактированием и вернуть туда после.

### 2.5. Не используйте propTypes. Учите Typescript.
Дело в том, что propTypes описывают только типы данных, передаваемые в компонент и то в довольно общих чертах. Нам же необходимо связать данные, приходящие со стороны бизнес-логики и отображаемые в компоненте.

### 2.6. Будьте осторожны с выбором готовых решений.
Готовые решения это хорошо, но всегда нужно учитывать, что готовый компонент тянет за собой зависимости. Не надо использовать **datepicker** из **material-ui**, если вам нужен только дэйтпикер. Ваше приложение будет огромным, потому что **material-ui** займёт треть его размера.

Лучше избегать готовых фрэймворком вроде **material-ui**, **bootstrap**, если у вас есть возможность верстать самому.

### 2.7. Правильно именуйте переменные
1. Все методы и функции именуются глаголами, описывающими то, что функция делает. Например: `getTitle`, `handleClick`.
2. Слушатели событий начинаются с `on`, например: `onTitleChange`, `onResize`, `onClose`.
3. Булевые переменные начинаются с `is`: `isActive`, `isDisabled`. Или с `has`: `hasError`.
4. Имена дочерних компонентов получаются добавлением к имени родительского суффикса, характеризующего компонент: родительский `LoginForm` и дочерний `LoginFormButtons`, так же `LoginFormButtonsCancel`.

## 3. CSS. Общие положения
### 3.1. Выберите один способ стилизовать приложение и используйте его
Бывает, что на проекте работает несколько разработчиков, и один использует `scss`, а другой - `styled-components`. Это недопустимо.

1. Styled-components удобны возможностью динамический темизации приложения (например, включение ночной темы переключателем), но замедляют приложение, генерируя CSS во время исполнения.
2. SCSS генерируется во время сборки, поэтому не замедляют приложение, но не имеют плюсов styled-components.

### 3.2. Избегайте стилизации с помощью style={}. Используйте классы.
Верстать с помощью написания стилей прямо в `style` - грубейшая ошибка. Не используйте даже для временной вёрстки, сразу пишите классы.

### 3.3. Используйте scoped-стили.
Scoped-стили это стили, которые имеют уникальное имя, генирируемое для компонента, в котором они подключены. 
1. В `create-react-app` создайте в папке с компонентом `styles.module.scss` и выполните `import styles from './styles.module.scss'`/. Дальше все классы будут доступны через `styles.class` и будут иметь уникальное имя. 
2. В `styled-components` создайте в папке с компонентом файл `styles.js` и экспортируйте все стили оттуда. 

`ВАЖНО:` **Не пишите стили в файле с компонентом: это недопустимо.**
`ВАЖНО:` **Не используйте глобальные стили для стилизации компонентов, это сделает вашу верстку неподдерживаемой в будущем.**

### 3.4. Используйте переменные и mixin'ы в scss
Выносите все в переменные: палитру приложения, границы размеров экранов устройств, величины отступов и загруглений. Используйте `@import "variables.scss"` для подключения переменных к вашему стилю или `sass-resources-loader` для того, чтобы они подклчились автоматически к каждому файлу.

Миксины это такие функции, только для css. Хороший совет - сразу сделать mixin'ы для медиа-запросов, например, миксины `@mobile`, `@tablet`, `@desktop` и т.д.

Не надо писать каждый раз `@media (max-width: 1700px {}` - такой код потом сложно поддерживать. 

### 3.5 Осторожно используйте аттрибуты в styled-components
В styled-components можно прокидывать пропсы компонента в стиль. Например:
```js
const Wrapper = styled.div`
    color: ${({ color }) => color};
`;
<Wrapper color="red" />
```
Не стоит использовать в качестве пропсов часто меняющиеся переменные, так как **styled-components** на каждый ререндер будет генерировать новый класс в CSS и менять инлайновые стили в DOM.

## 4. Особенности React
### 4.1 Используйте `PureComponent` и `memo`. Следите за ререндерами приложения.
React имеет собственный механизм отслеживания изменений данных и перерисовки DOM'а. Чтобы упростить ему эту задачу, используйте `PureComponent` и `memo`. Первый - для классов, второй - для функций.

`ВАЖНО:` Purecomponent и memo используют неглубокое сравнение, поэтому избегайте передачи в качестве пропсов объектов и массивов.

### 4.2. Не используйте стрелочные функции в качестве пропсов
Когда вы передаёте в качестве пропса стрелочную функцию, механизм определения необходимости перерендера React'а начинает сходить с ума. 

В примере ниже метод класса `handleClick` не изменился, однако, при каждом ререндере вы создаёте новую стрелочную функцию, уничтожаете старую, React видит, что ссылка на область памяти с функцией изменилась и ререндерит компонент `SomeComponent` и, вероятно, все его дочерние компоненты, если там всё сделано так же плохо.

В данном случае можно избежать создания стрелочной функции:

**Неправильно:**
```
<SomeComponent onClick={e => handleClick(e)} />
```
**Правильно:**
```
<SomeComponent onClick={handleClick} />
```

### 4.3. Правильно используйте ключи при рендере списков
При рендере списков из массива очень важно правильно описать связь между элементом списка и DOM-элементом, который его представляет. Для этого при рендере массива используется проп `key`. Этот ключ должен быть уникальным для элемента в списке, иначе вас ждет неожиданное поведение приложения.
```js
{
    items.map(item => <div key={item.id}>{item.name}</div>)
}
```
`ВАЖНО`: Не используйте в качестве ключей индексы элемента в списке, случайные числа и прочие вещи, не связанные с конкретным элементом списка.

### 4.4. Не используйте дополнительные render-методы. Используйте компоненты. Один файл - один компонент.
Часто можно видеть, код типа: 
```js
class SomeForm extends Component {
    renderItems() {
        return <span>{items}</span>
    }
    
    render() {
        return (
            <div>
                {renderItems()}
            </div>
        )
    }
}
```
Это выглядит как подходящее решение, пока ваш компонент не разросся и не оброс функционалом. Сразу используйте компоненты для таких вещей.

### 4.5. Правильно объявляйте переменные.
Не объявляйте никаких переменных в методе `return()` компонента, если не хотите, чтобы они вычислялись при каждом перерендере.
Переменные и функции, которые не зависят от компонента, не нужно объявлять в нём. Объявите их перед компонентом, вынесите в константы или утилиты.

### 4.6. Для функциональных компонентов используйте мемоизаторы
Мемоизаторы позволяют не переобъявлять переменные при каждом перерендере компонента, а делать это при изменении зависимостей этих переменных. Изучите хуки `useMemo`, `useCallback`, `useRef` и `useState`. 

`ВАЖНО:` правильно указывайте зависимости для хуков-мемоизаторов. Не забывайте прописывать зависимостями все переменные, в том числе функции, которые используются внутри хука, иначе вас ждут неожиданные последствия.

### 4.7. Для компонентов-классов используйте стрелочные функции вместо методов
С давних пор существует проблема потери контекста при вызове метода класса в реакт-компонентах. Допустим, у вас есть код:
```js
class SomeForm extends Component {
   doSomething() {
        console.log(this)
   }
   
   render() {
       return (
            <button onClick={doSomething}>Press me</button> 
       )
   }
}
```
При нажатии на кнопку в консоль попадёт `undefined`, так как произошла потеря контекста. Решением раньше было привязать в конструкторе класса контекст:
```js
class SomeForm extends Component {
    constructor(props) {
        this.doSomething = this.doSomething.bind(this)
    }
    
    // ...
}
```

Сейчас же вы можете использовать стрелочные функции вместо методов, они подхватят контекст в месте вызова:
```js
class SomeForm extends Component {
    doSomething = () => {
        console.log(this)
    }
    
    // ...
}
```

### 4.8. Деструктурируйте
Деструктуризация улучшает читаемость кода.
**Неправильно:**
```js
render () {
    return <div><h1>{this.props.title}</h1><div>{this.state.content}</div></div>
}
```
**Правильно:**
```js
render () {
    const { props: { title }, state: { content } } = this
    return <div><h1>{title}</h1><div>{content}</div></div>
}
```

**Для функциональных компонентов деструктурируйте пропсы:**
```js
const SomeForm = ({ title, content }) => (
    <div><h1>{title}</h1><div>{content}</div></div>
);
```

### 4.9. Используйте classNames для описания классов
Пакет *classNames* позволяет удобно описывать класс компонента для различных его состояний:
**Неправильно:**
```
<div className={`row primary ${isActive ? 'active' : ''}`} />
```
**Правильно:**
```js
<div className={classNames('row','primary', { active: isActive })} />
```

### 4.10. Экспортируйте компоненты правильно
Default exports это не плохо, но обычные экспорты удобнее в использовании. Кроме этого, при default-экспорте неопытные пользователи часто импортят компонент не под тем именем, под которым экспортнули, что вызывает трудности.

Если вы используете обычный export, разделите объявление класса/функции и его экспорт. Это позволит утилитам для разработки правильно вывести имя компонента:

В ReactDevTools и в выводе ошибок выведет Unnamed:
```js
export const SomeComponent = () => <div />
``` 
В ReactDevTools и в выводе ошибок выведет SomeComponent:
```js
const SomeComponent = () => <div />
export { SomeComponent }
```

### 4.11. Используйте aliases
Не нужно использовать длинный относительный путь к компоненту, есть много средств для того, чтобы писать импорты кратко. Стоит создать *alias* для абсолтного пути `./src` => `~/` и использовать его.
1. В *Typescript* используйте `baseUrl` и `paths` в файле `tsconfig.json`
2. В *eslint* используйте [eslint-import-resolver-alias](https://www.npmjs.com/package/eslint-import-resolver-alias)
3. В *babel* используйте [babel-plugin-module-resolver](https://www.npmjs.com/package/babel-plugin-module-resolver)

**Неправильно**:
```
import Wrapper from '../../../../../containers/Wrapper'
```
**Правильно**:
```
import Wrapper from '~/containers/Wrapper'
```

`СОВЕТ:` не используйте альясы вида `@components`, гораздо удобнее назначить альяс на `./src/` вроде `~/` и использовать его  везде.

### 4.12. Используйте хуки
Изучите документацию по реакт-хукам и используйте их. Это гораздо удобнее классов, а возможностей гораздо больше. Единственный минус - хуки сложно тестировать.
Пишите свои хуки для того, чтобы переиспольовать код. Документация здесь: https://ru.reactjs.org/docs/hooks-custom.html

### 4.13. Никаких {...props}
Деструктуризация пропсов для передачи дочернему компоненту кажется удобным решением, но в будущем невозможно понять, что именно вы передали. Описывайте все передаваемые пропсы:

**Неправильно:**
```js
return <Element {...props} />
```
**Правильно:**
```js
const { title, content } = props;
return <Element title={title} content={content} />
```

### 4.14. Не передавайте пропсы на слишком много уровней. Используйте контекст и connect.

## 5. Redux
### 5.1. Правильно пишите mapDispatchToProps:
Функция mapDispatchToProps используется для передачи функции dispatch в redux-экшны. У неё есть несколько форм записей.
`ВАЖНО:` не изменяйте данные внутри mapDispatchToProps перед передачей в экшн. Это катастрофически ухудшает читаемость кода.

**Неправильно:**
Здесь разработчик назвал коллбэк, передаваемый в пропсы `someActionHandler`, чтобы он не затенялся `someAction` из импорта. Так же он написал сложную логику внутри `mapDispatchToProps` для объединения `title` и `content` в одну переменную, требуемую экшном:
```js
import { someAction } from '~/redux/actions'

const mapDispatchToProps = dispatch => {
    return {
        someActionHandler: (title: string, content: string) =>  dispatch(someAction(`${title}-${content}`));
    }
}

// ...где-то внутри класса

    doSomething() {
        this.props.someActionHandler(this.state.title, this.state.content);
    }
```

**Правильно:**
В данном случае мы используем `import * as ACTIONS`, чтобы импортированная функция `someAction` не затеняла `someAction`, передаваемую в пропсы. Переменные `title` и `content` мы объединяем внутри метода класса. Экшн someAction мы не оборачиваем в dispatch вовсе, этим займётся сам `connect`:
```js
import * as ACTIONS from '~/redux/actions'

const mapDispatchToProps = {
    someAction: ACTIONS.someAction
}

// ...где-то внутри класса

    doSomething() {
        const text = `${this.state.title}-${this.state.content}`;
        this.props.someAction(text);
    }
```
### 5.2 Не обрабатывайте данные в mapStateToProps. Используйте селекторы.
Какие-либо действия с данными внутри mapStateToProps улучшают производительность, так как производятся при изменении этих данных, но запутывают разработчика.

`ВАЖНО:` mapStateToProps должен просто передавать в компонент данные из стора, не изменяя их по пути.

**Неправильно:**
Разработчик отфильтровал данные внутри mapStateToProps. Если таких операций будет много, нам будет сложно разобраться, откда приходят данные.
```js
const mapStateToProps = (state: IState) => {
    return ({
        activeItems: state.list.items.filter(item => item.isActive)
    })
}
```

***Правильно:***
Разработчик просто передал данные из стора, а потом отфильтровал их, используя мемоизатор, внутри компонента. Кроме этого, он улучшил читаемость, используя заранее заготовленную функцию-селектор:

```js
import { selectListItems } from '~/redux/list/selectors'

const mapStateToProps = (state: IState) => {
    items: selectListItems(state)
}

const SomeForm = ({ items }) => {
    const activeItems = useMemo(() => state.list.items.filter(item => item.isActive), [items])
    
    return activeItems.map(...);
}
```

### 5.3. Правильно типизируйте пропсы:
Если вы используете `redux`, не нужно каждый раз заново описывать пропсы приходящие из него. Используйте этот удобный сниппет:
```typescript
const mapStateToProps = (state: IState) => ({ items: selectListItems(state) });
const mapDispatchToProps = { someAction: ACTIONS.someAction }

type IComponentProps = ReturnType<typeof mapStateToProps> & typeof mapDispatchToProps & { /* собственные пропсы компонента */}
```
## 5.4. Не используйте redux-thunk, учите redux-saga.
При всей простоте `redux-thunk`, практически любой проект в какой-то момент перерастает возможности этой утилиты. Используйте `redux-saga`, которая позволяет решать более сложные задачи, связанные с асинхронными действиями, происходящими в приложении.

### 5.5. Редьюсеры не должны обрабатывать данные, только хранить.
Часто неопытные пользователи производят действия над данными внутри редьюсера. Это неправильно. 

Экшны в редьюсере лучше разделить на два типа: 
1. Первый тип напрямую заменяет данные в сторе, не обрабатывая их.
2. Второй тип сигнализирует `redux-saga` о том, что нужно обработать какие-либо данные. При этом, этот экшн сам не изменяет данные в редьюсере, этим занимается сага, вызывающая метод первого типа в результате обработки.

**Неправильно:**
1. Вызвать экшн `setTitle(name: 'Ivan', surname: 'Petrov')`
2. В редьюсере записать новое значение в поле `title: 'Ivan Petrov'`.

**Правильно:**
1. Вызвать экшн `changeTitle({ name: 'Ivan', surname: 'Petrov' })`
2. Сага, слушающая событие `CHANGE_TITLE` обрабатывает данные
3. Сага вызывает экшн `setTitle({ title: 'Ivan Petrov' })
4. Экшн изменяет значение в поле на `title: 'Ivan Petrov'`

Выглядит как усложнение, но разработчик, пришедший после вас, не должен будет два часа искать, на каком этапе изменились его данные.

## 5.6. Используйте утилиту createReducer из redux-toolkit
Привычным нам редьюсер выглядит как простыня из `case ACTION:`. Эта утилита позволяет разнести экшны по функциям, которые будут принимать `payload` и изменять данные. Ссылка: [createReducer](https://redux-toolkit.js.org/api/createReducer)

## 5.7. Используйте redux-persist для хранения данных в localStorage
Не нужно городить собственных утилит для хранения стора между запусками приложения. Используйте [redux-persist](https://github.com/rt2zz/redux-persist)
```ВАЖНО:``` грамотно выбирайте, какие данные хранить между запусками. 
```ВАЖНО:``` используйте `persistReducer`, а не `persistStore`, во втором сложнее запретить хранение определенных ключей редьюсера

### 5.8. Используйте константы для именования экшнов.
Это позволит избежать ошибок при написании экшна. Это же касается и саг.
**Неправильно:**
```js
const someAction = (text: string) => ({ type: "SOME_ACTION", text });
```

**Правильно:**
```js
const ACTIONS = {
        SOME_ACTION: 'SOME_ACTION'
}

const someAction = (text: string) => ({ type: ACTIONS.SOME_ACTION, text });
```
### 5.9. Типизируйте данные, приходящие в саги
В данном случае мы получаем тип, возвращаемый экшном `someAction` и применяем его в саге, которую он вызывает:
```js
function* someActionSaga({ text }: ReturnType<typeof someAction>) {
    // ...
}
```
В данном случае мы получаем из стора данные и явно указываем их тип к селектору, с помощью которого их получили (сама сага этого не умеет):
```typescript
type Unwrap<T> = T extends Promise<infer U> ? U : T;

function* someActionSaga() {
    // Для селекта
    const currentTitle: ReturnType<typeof selectCurrentTitle> = yield select(selectCurrentTitle)
    
    // Для асинхронных вызовов получаем результат из промайса:
    const result: Unwrap<ReturnType<typeof getTitle>> = yield call(getTitle)
}
```

### 5.10. Используйте эффекты саги
Вот основные эффекты, которые вам пригодятся:
1. `call` - для вызова асинхронных вызовов, например для запроса с api
2. `put` - для отправки экшнов в редьюсер, например `yield put(someAction("text"))`
3. `select` - для получения текущего состояния стора и данных из него
4. `takeEvery` - для прослушивания экшнов и запуска саг на каждый из них
5. `takeLatest` - для прослушивания экшнов и запуска саг на каждый из них с остановкой предыдущей саги
6. `take` - для остановки саги до получения экшна
7. `race` - для запуска нескольких асинхронных действий с отменой всех, кроме завершившегося первым
8. `all` - для ожидания выполнения всех действий
9. `fork` - форкнет сагу из текущей саги. При этом, можно остановить фокнутую сагу после запуска

## 6. Typescript
### 6.1. Не допускайте использования any
Возьмите за правило: весь код должен быть типизирован сейчас. Не отступайте от этого правила во время разработки.

### 6.2. Старайтесь заводить общие типы и расширять их, но только там, где нужно
Наследуйтесь от интерфейсов, используйте встроенные дженерики `Partial`, `Pick` и `Omit`

### 6.3. Оборачивайте состояние редьюсера в ReadOnly
Защитите мутацию данных в редьюсере, обернув его изначально состояние в Readonly<>

### 6.4. Избегайте лишних описаний типов
Если вы передаёте в пропсы компонента функцию, не нужно её описывать заново, просто укажите тип пропса `typeof funcName`. Если вы получаете какой-то пропс из редьюсера, так же сошлитесь на тип из редьюсера, например,  `title: IState['list']['title']`. 

### 6.5. Если пакет не типизирован, ищите описание в @types или напишите своё
Для большинства популярных пакетов типизацию можно добавить, установив пакет с именем `@types/package-name`. Если не получилось, а типизация очень нужна, стоит написать её самому: https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html

## 7. Оптимизация приложения
### 7.1. Анализируте зависимости и размер бандла
На всех этапах разработки используйте утилиту для анализа размера бандла. Она вот тут: https://chrisbateman.github.io/webpack-visualizer/, там же есть инструкции. 
Нам важно понять, какие зависимости тянут наши компоненты, от каких можно избавиться, какие заменить, какой пакет выбрать из условий его размера в бандле. 

### 7.2. Вопросы к momentjs
Momentjs катастрофически увеличивает размер бандла, так как тащит за собой локали. Выхода существует два:
1. Используйте date-fns. Импортируйте функции напрямую, например, `import format from 'date-fns/format'` вместо `import { format } from 'date-fns'
2. Гуглите как отключить ненужные локали: https://github.com/jmblog/how-to-optimize-momentjs-with-webpack

### 7.3. Для lodash используйте плагин для babel
Проблема в том, что когда вы используйте какую-нибудь функцию из lodash, в бандл попадает весь lodash. Используйте этот плагин: `babel-plugin-lodash` или импортируйте функции напрямую из файлов, в которых они написаны.

### 7.4. Подгружайте компоненты по мере необходимости
Не обязательно включать сразу все компоненты в бандл. Используйте React.lazy для того, чтобы вынести некоторые компоненты в отдельные js-файлы и подгружать их по мере необходимости.
Вся информация тут: https://ru.reactjs.org/docs/code-splitting.html

### 7.5. Аналзируйте конфликтующие зависимости
Часто ошибки в приложении вызваны тем что разные пакеты подтянули разную версию зависимости одного и того же пакета. Для анализа таких ситуаций используйте `npm list package-name` и `npm dedupe`.
